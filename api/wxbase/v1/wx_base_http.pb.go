// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.7.0
// - protoc             v4.23.4
// source: wxbase/v1/wx_base.proto

package v1

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationOfficialAccountAddOfficialAccount = "/helloworld.v1.OfficialAccount/AddOfficialAccount"
const OperationOfficialAccountDeleteOfficialAccount = "/helloworld.v1.OfficialAccount/DeleteOfficialAccount"
const OperationOfficialAccountGetOfficialAccountList = "/helloworld.v1.OfficialAccount/GetOfficialAccountList"
const OperationOfficialAccountUpdateOfficialAccount = "/helloworld.v1.OfficialAccount/UpdateOfficialAccount"
const OperationOfficialAccountWxCallback = "/helloworld.v1.OfficialAccount/WxCallback"

type OfficialAccountHTTPServer interface {
	// AddOfficialAccount ------------ internal ----------
	// 添加公众号
	AddOfficialAccount(context.Context, *AddOfficialAccountRequest) (*AddOfficialAccountReply, error)
	// DeleteOfficialAccount 删除公众号
	DeleteOfficialAccount(context.Context, *DeleteOfficialAccountRequest) (*DeleteOfficialAccountReply, error)
	// GetOfficialAccountList 获取公众号列表
	GetOfficialAccountList(context.Context, *GetOfficialAccountListRequest) (*GetOfficialAccountListReply, error)
	// UpdateOfficialAccount 修改公众号
	UpdateOfficialAccount(context.Context, *UpdateOfficialAccountRequest) (*UpdateOfficialAccountReply, error)
	// WxCallback 微信回调
	WxCallback(context.Context, *WxCallbackRequest) (*WxCallbackReply, error)
}

func RegisterOfficialAccountHTTPServer(s *http.Server, srv OfficialAccountHTTPServer) {
	r := s.Route("/")
	r.GET("/wx/new", _OfficialAccount_WxCallback0_HTTP_Handler(srv))
	r.POST("/v1/official_account", _OfficialAccount_AddOfficialAccount0_HTTP_Handler(srv))
	r.PUT("/v1/official_account", _OfficialAccount_UpdateOfficialAccount0_HTTP_Handler(srv))
	r.DELETE("/v1/official_account", _OfficialAccount_DeleteOfficialAccount0_HTTP_Handler(srv))
	r.GET("/v1/official_account", _OfficialAccount_GetOfficialAccountList0_HTTP_Handler(srv))
}

func _OfficialAccount_WxCallback0_HTTP_Handler(srv OfficialAccountHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in WxCallbackRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationOfficialAccountWxCallback)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.WxCallback(ctx, req.(*WxCallbackRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*WxCallbackReply)
		return ctx.Result(200, reply)
	}
}

func _OfficialAccount_AddOfficialAccount0_HTTP_Handler(srv OfficialAccountHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in AddOfficialAccountRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationOfficialAccountAddOfficialAccount)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.AddOfficialAccount(ctx, req.(*AddOfficialAccountRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*AddOfficialAccountReply)
		return ctx.Result(200, reply)
	}
}

func _OfficialAccount_UpdateOfficialAccount0_HTTP_Handler(srv OfficialAccountHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in UpdateOfficialAccountRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationOfficialAccountUpdateOfficialAccount)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.UpdateOfficialAccount(ctx, req.(*UpdateOfficialAccountRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*UpdateOfficialAccountReply)
		return ctx.Result(200, reply)
	}
}

func _OfficialAccount_DeleteOfficialAccount0_HTTP_Handler(srv OfficialAccountHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in DeleteOfficialAccountRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationOfficialAccountDeleteOfficialAccount)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.DeleteOfficialAccount(ctx, req.(*DeleteOfficialAccountRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*DeleteOfficialAccountReply)
		return ctx.Result(200, reply)
	}
}

func _OfficialAccount_GetOfficialAccountList0_HTTP_Handler(srv OfficialAccountHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetOfficialAccountListRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationOfficialAccountGetOfficialAccountList)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetOfficialAccountList(ctx, req.(*GetOfficialAccountListRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetOfficialAccountListReply)
		return ctx.Result(200, reply)
	}
}

type OfficialAccountHTTPClient interface {
	AddOfficialAccount(ctx context.Context, req *AddOfficialAccountRequest, opts ...http.CallOption) (rsp *AddOfficialAccountReply, err error)
	DeleteOfficialAccount(ctx context.Context, req *DeleteOfficialAccountRequest, opts ...http.CallOption) (rsp *DeleteOfficialAccountReply, err error)
	GetOfficialAccountList(ctx context.Context, req *GetOfficialAccountListRequest, opts ...http.CallOption) (rsp *GetOfficialAccountListReply, err error)
	UpdateOfficialAccount(ctx context.Context, req *UpdateOfficialAccountRequest, opts ...http.CallOption) (rsp *UpdateOfficialAccountReply, err error)
	WxCallback(ctx context.Context, req *WxCallbackRequest, opts ...http.CallOption) (rsp *WxCallbackReply, err error)
}

type OfficialAccountHTTPClientImpl struct {
	cc *http.Client
}

func NewOfficialAccountHTTPClient(client *http.Client) OfficialAccountHTTPClient {
	return &OfficialAccountHTTPClientImpl{client}
}

func (c *OfficialAccountHTTPClientImpl) AddOfficialAccount(ctx context.Context, in *AddOfficialAccountRequest, opts ...http.CallOption) (*AddOfficialAccountReply, error) {
	var out AddOfficialAccountReply
	pattern := "/v1/official_account"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationOfficialAccountAddOfficialAccount))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *OfficialAccountHTTPClientImpl) DeleteOfficialAccount(ctx context.Context, in *DeleteOfficialAccountRequest, opts ...http.CallOption) (*DeleteOfficialAccountReply, error) {
	var out DeleteOfficialAccountReply
	pattern := "/v1/official_account"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationOfficialAccountDeleteOfficialAccount))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "DELETE", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *OfficialAccountHTTPClientImpl) GetOfficialAccountList(ctx context.Context, in *GetOfficialAccountListRequest, opts ...http.CallOption) (*GetOfficialAccountListReply, error) {
	var out GetOfficialAccountListReply
	pattern := "/v1/official_account"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationOfficialAccountGetOfficialAccountList))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *OfficialAccountHTTPClientImpl) UpdateOfficialAccount(ctx context.Context, in *UpdateOfficialAccountRequest, opts ...http.CallOption) (*UpdateOfficialAccountReply, error) {
	var out UpdateOfficialAccountReply
	pattern := "/v1/official_account"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationOfficialAccountUpdateOfficialAccount))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "PUT", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *OfficialAccountHTTPClientImpl) WxCallback(ctx context.Context, in *WxCallbackRequest, opts ...http.CallOption) (*WxCallbackReply, error) {
	var out WxCallbackReply
	pattern := "/wx/new"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationOfficialAccountWxCallback))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

const OperationMiniProgramAddMiniProgram = "/helloworld.v1.MiniProgram/AddMiniProgram"
const OperationMiniProgramGetOpenidByCode = "/helloworld.v1.MiniProgram/GetOpenidByCode"

type MiniProgramHTTPServer interface {
	// AddMiniProgram ------------ internal ----------
	// 添加小程序
	AddMiniProgram(context.Context, *AddMiniProgramRequest) (*AddMiniProgramReply, error)
	// GetOpenidByCode -------------- wx --------------
	// 通过code获取openid
	GetOpenidByCode(context.Context, *GetOpenidByCodeRequest) (*GetOpenidByCodeReply, error)
}

func RegisterMiniProgramHTTPServer(s *http.Server, srv MiniProgramHTTPServer) {
	r := s.Route("/")
	r.GET("/v1/wx/openid", _MiniProgram_GetOpenidByCode0_HTTP_Handler(srv))
	r.POST("/v1/mini_program", _MiniProgram_AddMiniProgram0_HTTP_Handler(srv))
}

func _MiniProgram_GetOpenidByCode0_HTTP_Handler(srv MiniProgramHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetOpenidByCodeRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationMiniProgramGetOpenidByCode)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetOpenidByCode(ctx, req.(*GetOpenidByCodeRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetOpenidByCodeReply)
		return ctx.Result(200, reply)
	}
}

func _MiniProgram_AddMiniProgram0_HTTP_Handler(srv MiniProgramHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in AddMiniProgramRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationMiniProgramAddMiniProgram)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.AddMiniProgram(ctx, req.(*AddMiniProgramRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*AddMiniProgramReply)
		return ctx.Result(200, reply)
	}
}

type MiniProgramHTTPClient interface {
	AddMiniProgram(ctx context.Context, req *AddMiniProgramRequest, opts ...http.CallOption) (rsp *AddMiniProgramReply, err error)
	GetOpenidByCode(ctx context.Context, req *GetOpenidByCodeRequest, opts ...http.CallOption) (rsp *GetOpenidByCodeReply, err error)
}

type MiniProgramHTTPClientImpl struct {
	cc *http.Client
}

func NewMiniProgramHTTPClient(client *http.Client) MiniProgramHTTPClient {
	return &MiniProgramHTTPClientImpl{client}
}

func (c *MiniProgramHTTPClientImpl) AddMiniProgram(ctx context.Context, in *AddMiniProgramRequest, opts ...http.CallOption) (*AddMiniProgramReply, error) {
	var out AddMiniProgramReply
	pattern := "/v1/mini_program"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationMiniProgramAddMiniProgram))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *MiniProgramHTTPClientImpl) GetOpenidByCode(ctx context.Context, in *GetOpenidByCodeRequest, opts ...http.CallOption) (*GetOpenidByCodeReply, error) {
	var out GetOpenidByCodeReply
	pattern := "/v1/wx/openid"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationMiniProgramGetOpenidByCode))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}
